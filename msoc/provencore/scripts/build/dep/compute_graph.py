#!/usr/bin/env python3

"""ProvenCore lib dependency graph explorer

This script computes a dependency graph for libraries linked in a ProvenCore
application, based on the .dep files generated by ProvenCore's build system. Its
main purpose is to output a list of linker flags in the right order so that
libraries dependencies can be resolved.
"""


import abc
import os
from typing import Union, Optional, List, Set


def format_list(s: Set['Lib']) -> str:
    """Format a set of libraries into a human readable list"""
    if not s:
        return ""
    l = sorted([str(ll) for ll in s])
    if len(l) == 1:
        return l[0]
    return ", ".join(l[:-1]) + " and " + l[-1]


class LibOrLibGroup(metaclass=abc.ABCMeta):
    """Parent class to describe a library or a library group"""

    def __init__(self) -> None:
        self.deps = set()
        self.used_by = set()

    @abc.abstractmethod
    def get_ldflags(self) -> str:
        """Returns the linker flags for this library or library group"""
        pass

    @abc.abstractmethod
    def describe(self, prefix: str = "") -> str:
        """Describe a library or library group in a human readable format"""
        pass

    def merge_cycle(self, cycle: List['LibOrLibGroup'],
            group: 'LibGroup') -> None:
        """Updates the dependency list after a merge with the resulting group"""
        if self.used_by.intersection(cycle):
            self.used_by.difference_update(cycle)
            self.used_by.add(group)
        if self.deps.intersection(cycle):
            self.deps.difference_update(cycle)
            self.deps.add(group)


class Lib(LibOrLibGroup):
    """Class describing a ProvenCore library

    Attributes:
      lib:
        A string that describes the path to the library under
        ${PATH_TO_SERVICES}/libraries
      libname:
        A string that uniquely identifies the library and corresponds to the
        basename of lib
      deps:
        A set of LibOrLibGroup instances that this library depends on
      used_by:
        A set of LibOrLibGroup instances that depend on this library
    """

    def __init__(self, graph: 'Graph', lib: str) -> None:
        """Creates a Lib instance

        Other Lib instances may be created recursively if they are listed as
        dependencies of the created Lib. Creating the Lib object also registers
        this new instance in the dictionary maintained by graph.

        Args:
          graph:
            A instance of Graph which is used to link library string
            representations to Lib instances
          lib:
            A string that describes the path to the library under
            ${PATH_TO_SERVICSE}/libraries
        """

        self.lib = lib
        self.libname = os.path.basename(lib)
        self.deps = set()
        self.used_by = set()

        graph.add_lib_in_dict(self)

        # Read dependencies information from the .dep file
        lib_dep_filename = os.path.join("lib", ".%s.dep" % self.libname)
        if os.path.isfile(lib_dep_filename):
            f = open(lib_dep_filename, 'r')
            for l in f:
                dep_name = l.rstrip('\n')
                if dep_name in graph.lib_dict:
                    ll = graph.lib_dict[dep_name]
                else:
                    ll = Lib(graph, dep_name)
                ll.used_by.add(self)
                self.deps.add(ll)

    def merge_cycle(self, cycle: List[LibOrLibGroup],
            group: 'LibGroup') -> None:
        """Description in parent class"""
        if not hasattr(self, 'used_by_orig'):
            self.used_by_orig = self.used_by.copy()
        return super().merge_cycle(cycle, group)

    def get_used_by_orig(self) -> Set['Lib']:
        """Returns the list of libraries that use this library"""
        return (self.used_by_orig if hasattr(self, 'used_by_orig')
                else self.used_by)

    def __str__(self) -> str:
        return "lib" + self.lib

    def describe(self, prefix: str = "") -> str:
        """Description in parent class"""
        return (prefix + str(self) + "\n" +
                prefix + ("# root dependency" if not self.used_by else
                          ("# required by %s" %
                              format_list(self.get_used_by_orig()))))

    def get_ldflags(self) -> str:
        """Description in parent class"""
        return "-l%s" % self.libname


class LibGroup(LibOrLibGroup):
    """Class describing a set of libraries with circular dependencies

    All Lib objects embedded in a LibGroup object are part of a same dependency
    cycle: if a and b are two libraries in a LibGroup instance, then there is a
    path from a to b in the dependency graph which consists only of elements of
    the LibGroup instance.

    Attributes:
      libs:
        A set of Lib instances that represents the libraries embedded in this
        group
      deps:
        A set of LibOrLibGroup instances that this library group depends on.
        I.e., l is in deps iff l is not in libs and there is a ll in libs such
        that ll depends on l.
      used_by:
        A set of LibOrLibGroup instances that depend on this library group.
        I.e., l is in used_by iff l is not in libs and there is a ll in libs
        such that l depends on ll.
    """

    def __init__(self, libs: List[LibOrLibGroup]) -> None:
        """Creates a library group consisting of the provided libs

        Args:
          libs:
            A list of libraries or libraries that will be included in the
            created library group. When library groups are passed in this list,
            the list of libraries they consist in are directly added to the
            created library group.
        """

        self.libs = set()
        self.deps = set()
        self.used_by = set()
        for l in libs:
            if isinstance(l, Lib):
                self.libs.add(l)
            else:
                assert isinstance(l, LibGroup), "Unexpected LibOrLibGroup subclass"
                self.libs.update(l.libs)
            self.deps.update(l.deps)
            self.used_by.update(l.used_by)
        self.deps.difference_update(self.libs)
        self.used_by.difference_update(self.libs)

    def get_ldflags(self) -> str:
        """Description in parent class"""
        return ("--start-group " +
                " ".join([l.get_ldflags() for l in sorted(self.libs,
                    key=lambda l: str(l))]) +
                " --end-group")

    def describe(self, prefix: str = "") -> str:
        """Description in parent class"""
        return (prefix + "Group {\n" +
                "\n\n".join([l.describe(prefix + "  ") for l in
                    sorted(self.libs, key=lambda l: str(l))]) +
                "\n" + prefix + "}")

    def __str__(self) -> str:
        return format_list(self.libs)


class GraphPath:
    """A class representing a path in the dependency graph

    Attributes:
      p:
        A list of LibOrLibGroup instances representing a path in the dependency
        graph
    """

    def __init__(self, p: List[LibOrLibGroup]) -> None:
        """Creates a GraphPath object from the provided list of LibOrLibGroup"""
        self.p = p

    def get_cycle(self) -> Optional[List[LibOrLibGroup]]:
        """Returns a cycle that this path ends with

        Returns:
          A list of LibOrLibGroup that represents a cyclic suffix of the path if
          the path ends with a cycle. None otherwise.
        """

        if len(self.p) < 2:
            return None

        l = self.p[-1]

        if l not in self.p[:-1]:
            return None

        return self.p[self.p.index(l):]


class DFSIterator:
    """An Iterator class used to traverse the dependency graph depth-first

    Note that this iterator is infinite as soon as there is a cycle in the
    dependency graph.

    Attributes:
      path:
        The last path returned by the iterator
      iters:
        A list of iterators sorted by depth in the graph
    """

    def __init__(self, graph: 'Graph') -> None:
        """Creates an iterator instances for the provided graph"""
        self.graph = graph
        self.path = None
        self.iters = []

    def __next__(self) -> GraphPath:
        if len(self.iters) == 0:
            self.iters = [iter(self.graph.libs)]
            self.path = GraphPath([next(self.iters[0])])
        elif len(self.path.p[-1].deps) > 0:
            self.iters.append(iter(self.path.p[-1].deps))
            self.path.p.append(next(self.iters[-1]))
        else:
            while len(self.iters) > 0:
                try:
                    self.path.p[-1] = next(self.iters[-1])
                    break
                except StopIteration:
                    self.path.p = self.path.p[:-1]
                    self.iters = self.iters[:-1]
            if len(self.iters) == 0:
                raise StopIteration

        return self.path

    def __iter__(self) -> 'DFSIterator':
        return self


class TreeIterator:
    """An Iterator class used to traverse the graph sorted by dependency

    This iterator produces vertices of the graph in such an order that a
    LibOrLibGroup instance is not produced until all other vertices that depend
    (indirectly) on it have been produced.

    Note that this iterator will raise an exception if there is a cycle in the
    dependency graph.
    """

    def __init__(self, graph: 'Graph') -> None:
        self.visited = set()
        self.to_visit = graph.libs

    def __next__(self) -> LibOrLibGroup:
        if len(self.to_visit) == 0:
            raise StopIteration

        try:
            l = next(filter(lambda ll: ll.used_by.issubset(self.visited),
                    sorted(self.to_visit, key=lambda l: str(l))))
        except StopIteration:
            raise Exception("Graph is not a tree")

        self.to_visit.remove(l)
        self.visited.add(l)
        self.to_visit.update(l.deps.difference(self.visited))

        return l

    def __iter__(self) -> 'TreeIterator':
        return self


class Graph:
    """Class representing a dependency graph

    Attributes:
      lib_dict:
        A dictionary which links library paths to LibOrLibGroup instances
      libs:
        A set of LibOrLibGroup instances that are the root of the dependency
        graph
    """

    def __init__(self, libs: List[str]) -> None:
        """Creates an instance of a dependency graph

        Args:
          libs:
            A list of strings that represents the paths to the roots of the
            dependency graph
        """

        self.lib_dict = {}
        self.libs = set([Lib(self, l) for l in libs if l not in self.lib_dict])

    def add_lib_in_dict(self, lib: Lib) -> None:
        """Add a Lib instance to the libraries dictionary"""
        self.lib_dict[lib.lib] = lib

    def dfs(self) -> DFSIterator:
        """Returns a depth-first search iterator for this graph"""
        return DFSIterator(self)

    def find_cycle(self) -> Optional[List[LibOrLibGroup]]:
        """Finds a cycle in the dependency graph

        Returns:
          A list of LibOrLibGroup instances representing a cycle in the graph or
          None if there is no cycle in the graph
        """

        try:
            return next(filter(lambda c: c is not None,
                map(lambda p: p.get_cycle(), self.dfs())))
        except StopIteration:
            return None

    def merge_cycle(self, cycle: List[LibOrLibGroup]) -> None:
        """Merges a cycle into a LibGroup and updates dependencies"""
        g = LibGroup(cycle)
        for l in g.deps:
            l.merge_cycle(cycle, g)
        for l in g.used_by:
            l.merge_cycle(cycle, g)
        for l in g.libs:
            self.lib_dict[l.lib] = g
        if self.libs.intersection(cycle):
            self.libs.difference_update(cycle)
            self.libs.add(g)

    def remove_cycles(self) -> None:
        """Removes all cycle in the graph by merging them into LibGroup"""
        while True:
            cycle = self.find_cycle()
            if cycle is None:
                break
            self.merge_cycle(cycle)

    def __iter__(self) -> TreeIterator:
        """Returns an iterator for the graph ordered by dependency

        Note that the iterator will raise an exception if the graph contains a
        cycle
        """

        return TreeIterator(self)

    def __str__(self) -> str:
        return ("# Topologically sorted dependencies\n\n" +
                "\n\n".join([l.describe() for l in self]))

    def print_graph(self) -> None:
        """Print a readable description of the graph"""
        print(str(self))

    def print_ldflags(self) -> None:
        """Prints the ldflags required for this graph"""
        print(" ".join([l.get_ldflags() for l in self]))


def print_graph(graph: Graph) -> None:
    """Prints a readable description of the provided graph"""
    graph.print_graph()


def print_ldflags(graph: Graph) -> None:
    """Prints the ldflags required for the provided graph"""
    graph.print_ldflags()


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('libs', metavar='lib', nargs='*',
            help='libraries to start with')
    parser.add_argument('--ldflags', dest='display', action='store_const',
            const=print_ldflags, default=print_graph,
            help='print ldflags instead of graph')
    parser.add_argument('-C', dest='wd',
            help='change directory before computing the graph')

    # Parse args
    args = parser.parse_args()

    if 'wd' in args:
        os.chdir(args.wd)

    # Create graph
    graph = Graph(args.libs)

    # Create groups for circular dependencies
    graph.remove_cycles()

    # Display the dependency graph in the selected format
    args.display(graph)
