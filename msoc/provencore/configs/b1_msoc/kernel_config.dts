/dts-v1/;

#include "b1_msoc.dtsi"

/ {
	nr-irq-hooks = <16>;
	nr-sched-queues = <15>;
	nr-procs = <125>;
	nr-regions = <100>;
	nr-shms = <75>;
	nr-dma-pages = <0x100>;
	nr-dyn-elfs = <0>;
	nr-dyn-elf-pages = <0>;
	nr-proc-shms = <4>;
	nr-proc-auths = <6>;
	nr-proc-stack-pages = <8>;

	rees {
		#address-cells = <2>;
		#size-cells = <2>;

		ree_ree: ree@ffe00000 {
			reg = <0x0 0xffe00000 0x0 0x200000>;
			interrupts = <14>;
			interrupt-names = "S_SGI";
		};

		isolation_shm: isolation_shm@81800000 {
			reg = <0x0 0x81800000 0x0 0xE00000>;
			memory-kind = "normal";
			memory-security-domain = "provencore";
		};
	};

	processes {
		/* Reminder: user is a special entry.
		 * It is mandatory, and will contain all properties specific to forked processes.
		 * All other entries are processes which will be started at boot time.
		 */
		ree: ree {
		    /* Name of the program to run.
		     * Two different processes can run the same program.
		     * We cannot yet pass arguments to programs.
		     * But each process knows its PID and can behave differently using this information.
		     */
		    elf = "ree/build/ree";
		    /* Domain:
		     * All processes of domain 0 (0 is a special domain) or domain 1 can
		     * communicate with this one. 0 is the default value.
		     */
		    domain = <1>;
		    /*
		     * Select the scheduling queue this process will be placed in.
		     * The value must be in the interval 0 .. min-priority.
		     * The highest priority queue is 0 (defaults to min-priority).
		     */
		    priority = <7>;
		    /* 2000 microseconds is the default value.
		     * This process is guaranteed to not be scheduled for more than 2 milliseconds.
		     * After that delay, the kernel will suspend the process and schedule an other
		     * suspended process instead.
		     */
		    quantum = <2000>;
		    /* Devices used by this application. */
		    devices = <&ree_ree>;
		    trap {
		        /* "all;" is equivalent to "sleep=<1>;send=<1>;receive=<1>;notify=<1>;sendrec=<1>;"
		         * All these operations will be allowed.
		         * send, receive and sendrec will still require that the other process will belong to
		         * domain 0 or our domain (here, 1).
		         */
		        all;
		    };
		    call {
		        /* Allowed system calls, see the documentation to get an exhaustive list. */
		        all;
		    };
		    target {
		        /* Processes which will be able to communicate with us.
		         * This list should include "system" to perform system calls,
		         * and user if you need IPCs to non privileged processes.
		         */
		        all;
		    };
		};

		uartin: uartin {
			elf = "uart/build/uart";
			priority = <7>;
			devices = <&dev_uart0>;
			trap {
				all;
			};
			call {
				all;
			};
			target {
				user;
				system;
				all;
			};
		};

		uartout: uartout {
			elf = "uart/build/uart";
			priority = <7>;
			devices = <&dev_uart0>;
			trap {
				all;
			};
			call {
				all;
			};
			target {
				user;
				system;
				all;
			};
		};

		toupper: toupper {
			elf = "toupper/build/toupper";
			domain = <1>;
			priority = <7>;
			devices = <&ree_ree>;
			trap {
				all;
			};
			call {
				all;
			};
			target {
				all;
			};
		};

	        hello: hello {
			elf = "hello/build/hello";
			domain = <1>;
			priority = <7>;
			trap {
				/*
				 * Required to display
				 * without sendrec : no any helloworld print
				 */
				send = <0>;
				sendrec = <1>;
				receive = <0>;
				/*
				 * notify trap reserved to sysprocs, it is ignored in the user process declaration
				 */
				notify = <0>;
				sleep = <0>;
			};
			call {
				/*
				 * No print without gitinfo and setauth
				 */
				fork = <0>;
				exit = <1>;
				exec = <0>;
				copy = <0>;
				break = <0>;
				getinfo = <1>;
				setauth = <1>;
				revoke = <0>;
				change_target = <0>;
				change_effector = <0>;
				change_revoker = <0>;
				irqctl = <0>;
				kill = <0>;
				iomap = <0>;
				iounmap = <0>;
				shm_alloc = <0>;
				shm_register = <0>;
				shm_unregister = <0>;
				shm_transfer = <0>;
				smc = <0>;
				hypercall = <0>;
				platctl = <0>;
			};
			target {
				allow = <&uartout>;
                system;
			};
		};

		user: user {
			allow-any-elf;
			priority = <7>;
			trap {
				all;
				notify = <0>;
			};
			call {
				all;
				fork = <0>;
				irqctl = <0>;
				iomap  = <0>;
				smc = <0>;
			};
			target {
				user;
				system;
				all;
			};
		};
	};
  };
