/*
 * Copyright (c) 2019-2023 ProvenRun S.A.S
 * All Rights Reserved.
 *
 * This software is the confidential and proprietary information of
 * ProvenRun S.A.S ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered
 * into with ProvenRun S.A.S
 *
 * PROVENRUN S.A.S MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE
 * SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT. PROVENRUN S.A.S SHALL
 * NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING,
 * MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 */
/**
 * @file
 * @brief Defines constants related to ipc traps.
 * @author Henri Chataing
 * @date February 13th, 2019 (creation)
 * @copyright (c) 2019-2023, ProvenRun S.A.S and/or its affiliates.
 *   All rights reserved.
 *
 * /!\ This file is shared between the kernel and applications.
 */

#ifndef _IPC_CONST_H_INCLUDED_
#define _IPC_CONST_H_INCLUDED_

/*
 * System call numbers that are passed when trapping to the kernel. The
 * numbers are carefully defined so that it can easily be seen (based on
 * the bits that are on) which checks should be done in sys_call().
 *
 * Bit '0' is the 'send' bit.
 * Bit '1' is the 'receive' bit.
 * Bit '2' is the 'notify' bit.
 * Bit '3' is the 'sleep' bit.
 * Bit '4' is the 'nonblock' bit.
 * Bit '5' is the 'fast kernel call' bit.
 *
 * Below are the valid combinations.
 */
#define SEND               1    /* 0 0 0 0 0 1 : blocking send */
#define RECEIVE            2    /* 0 0 0 0 1 0 : blocking receive */
#define SENDREC            3    /* 0 0 0 0 1 1 : SEND + RECEIVE */
#define NOTIFY             4    /* 0 0 0 1 0 0 : notify */
#define SLEEP              8    /* 0 0 1 0 0 0 : sleep for some time */
#define SEND_NONBLOCK      17   /* 0 1 0 0 0 1 : non-blocking send */
#define RECEIVE_NONBLOCK   18   /* 0 1 0 0 1 0 : non-blocking receive */
#define SENDREC_NONBLOCK   19   /* 0 1 0 0 1 1 : non-blocking SEND + RECEIVE */
#define FAST_KERNEL_CALL   35   /* 1 0 0 0 1 1 : fast kernel call */

#ifndef __ASSEMBLER__

#include <inttypes.h>
#include <limits.h>
#include <stdint.h>

/** Type of 'Secure PID' */
typedef uint64_t s_pid_t;

/** Format specifier for s_pid_t in decimal */
#define PRIuPID                 PRIu64
/** Format specifier for s_pid_t in hexdecimal */
#define PRIxPID                 PRIx64

/** Type of messages exchanged *via* inter-process communications (IPC). */
typedef struct {
    uint64_t m_source;
    uint64_t uptime; /**< in Âµs */
    uint32_t m_type;
    uint32_t m1;
    uint64_t m2;
    uint32_t m3;
    uint32_t m4;
    uint64_t m5;
    uint64_t m6;
} compact_message;

/** Constant to execute an IPC call without any timeout */
#define NO_TIMEOUT              UINT64_MAX

/**
 * Identity of the HARDWARE task which is the source of userland
 * interrupt notifications.
 */
#define HARDWARE                (UINT64_C(2) * 8)

/**
 * Constant PIDS for kernel tasks
 */
#define PM_ID                   (UINT64_C(1) * 8)

/** Special target to accept messages from all sources. */
#define TARGET_ANY              (UINT64_C(1) << 63)

/* Kernel notification types */
#define MSOURCE_NOTIFY_FLAG     (UINT64_C(1) << 63)
#define MSOURCE_RECEIVE_FLAG    (UINT64_C(1) << 62)
#define MSOURCE_MASK            (~(MSOURCE_NOTIFY_FLAG | MSOURCE_RECEIVE_FLAG))

/* Special PIDs guaranteed not to collide we live ones.
 * To build them, we choose static PIDs which are of the form
 * 0x00xyyyyyyyyyyyyz where x = {0, 1, 2, 3}, y = hex numbers, z = {0, 8}
 * Out of them, only the first 128 are valid.
 * Thus we could set a 32 bits range of invalid PIDs of the form:
 * 0x003fyyyyyyyy0000
 *
 * Note that there are pids which cannot be generated by the kernel,
 * and for which is_invalid_pid(pid) still does not hold.
 *
 * INVALID_PID(code) is really to allow functions returning either a valid pid,
 * or a special value (usually an error code).
 *
 * This can also be used to initialize variables to values which are guaranteed
 * to not collide with an existing pid.
 */
#define INVALID_PID_CODE_WIDTH  (32)
#define INVALID_PID_CODE_SHIFT  (16)
#define INVALID_PID_LEFT        (UINT64_C(0x003f))
#define INVALID_PID_RIGHT       (UINT64_C(0x0000))
#define INVALID_PID(code) \
    (((((((uint64_t)(code)) & ((UINT64_C(1) << INVALID_PID_CODE_WIDTH) - 1)) | \
        (INVALID_PID_LEFT << INVALID_PID_CODE_WIDTH))) << INVALID_PID_CODE_SHIFT) | \
     INVALID_PID_RIGHT)

#endif /* __ASSEMBLER__ */

#endif /* _IPC_CONST_H_INCLUDED_ */
