From 2bc804db724d2a09ab27220768a77b038d67250d Mon Sep 17 00:00:00 2001
From: Aymeric PLOTON <aymeric.ploton@provenrun.com>
Date: Wed, 4 Oct 2023 14:07:24 +0200
Subject: [PATCH] Run ProvenCore-A on dedicated core : core 3

---
 include/lib/psci/psci.h                 |  1 +
 lib/psci/psci_on.c                      |  2 +-
 lib/psci/psci_private.h                 |  3 ---
 lib/psci/psci_setup.c                   | 13 +++++++++
 plat/nxp/s32/include/s32_platform_def.h |  9 +++++++
 services/spd/pncd/pncd_common.c         |  4 +--
 services/spd/pncd/pncd_main.c           | 35 +++++++++++++++++++++++--
 7 files changed, 59 insertions(+), 8 deletions(-)

diff --git a/include/lib/psci/psci.h b/include/lib/psci/psci.h
index b56e98b5f..b54cf0f41 100644
--- a/include/lib/psci/psci.h
+++ b/include/lib/psci/psci.h
@@ -331,6 +331,7 @@ typedef struct plat_psci_ops {
  * Function & Data prototypes
  ******************************************************************************/
 unsigned int psci_version(void);
+int psci_cpu_on_start(u_register_t target_cpu, const entry_point_info_t *ep);
 int psci_cpu_on(u_register_t target_cpu,
 		uintptr_t entrypoint,
 		u_register_t context_id);
diff --git a/lib/psci/psci_on.c b/lib/psci/psci_on.c
index dd48e105d..bf2f5517e 100644
--- a/lib/psci/psci_on.c
+++ b/lib/psci/psci_on.c
@@ -229,5 +229,5 @@ void psci_cpu_on_finish(unsigned int cpu_idx, const psci_power_state_t *state_in
 	 * information that we had stashed away during the cpu_on
 	 * call to set this cpu on its way.
 	 */
-	cm_prepare_el3_exit(NON_SECURE);
+	cm_prepare_el3_exit(cpu_idx == BL32_MAIN_CPU ? SECURE : NON_SECURE);
 }
diff --git a/lib/psci/psci_private.h b/lib/psci/psci_private.h
index 72bd6bd11..c410dece5 100644
--- a/lib/psci/psci_private.h
+++ b/lib/psci/psci_private.h
@@ -303,9 +303,6 @@ void psci_do_pwrdown_sequence(unsigned int power_level);
 void prepare_cpu_pwr_dwn(unsigned int power_level);
 
 /* Private exported functions from psci_on.c */
-int psci_cpu_on_start(u_register_t target_cpu,
-		      const entry_point_info_t *ep);
-
 void psci_cpu_on_finish(unsigned int cpu_idx, const psci_power_state_t *state_info);
 
 /* Private exported functions from psci_off.c */
diff --git a/lib/psci/psci_setup.c b/lib/psci/psci_setup.c
index 9c37d63f2..55b663841 100644
--- a/lib/psci/psci_setup.c
+++ b/lib/psci/psci_setup.c
@@ -23,6 +23,13 @@
  */
 CASSERT(PLATFORM_CORE_COUNT <= (PSCI_MAX_CPUS_INDEX + 1U), assert_psci_cores_overflow);
 
+/******************************************************************************
+ * Required to start a secondary core reserved for a single-core kernel
+ * in the secure world.
+ *****************************************************************************/
+
+extern uintptr_t s32_warmboot_entry;
+
 /*******************************************************************************
  * Per cpu non-secure contexts used to program the architectural state prior
  * return to the normal world.
@@ -240,6 +247,12 @@ int __init psci_setup(const psci_lib_args_t *lib_args)
 	psci_flush_dcache_range((uintptr_t)&psci_plat_pm_ops,
 					sizeof(psci_plat_pm_ops));
 
+	psci_flush_dcache_range((uintptr_t)&psci_cpu_pd_nodes,
+                                       sizeof(psci_cpu_pd_nodes));
+
+	psci_flush_dcache_range((uintptr_t)&s32_warmboot_entry,
+                                        sizeof(s32_warmboot_entry));
+
 	/* Initialize the psci capability */
 	psci_caps = PSCI_GENERIC_CAP;
 
diff --git a/plat/nxp/s32/include/s32_platform_def.h b/plat/nxp/s32/include/s32_platform_def.h
index 867d6c124..e4866d314 100644
--- a/plat/nxp/s32/include/s32_platform_def.h
+++ b/plat/nxp/s32/include/s32_platform_def.h
@@ -149,7 +149,16 @@
 #define BL31_BASE		(S32_PMEM_START)
 #define BL31_LIMIT		(S32_PMEM_END)
 #define BL31_SIZE		(BL31_LIMIT - BL31_BASE + 1)

+/* Assign dedicated core to ProvenCore-A if not already done */
+#ifndef BL32_MAIN_CPU
+#ifdef MSOC_CORE_ALLOC
+#define BL32_MAIN_CPU          1
+#else
+#define BL32_MAIN_CPU          1
+#endif
+#endif /*BL32_MAIN_CPU*/
+
 /* FIXME value randomly chosen; should probably be revisited */
 #define PLATFORM_STACK_SIZE		0x4000
 
diff --git a/services/spd/pncd/pncd_common.c b/services/spd/pncd/pncd_common.c
index 6fdb6293f..b7065f517 100644
--- a/services/spd/pncd/pncd_common.c
+++ b/services/spd/pncd/pncd_common.c
@@ -33,9 +33,9 @@ void pncd_init_pnc_ep_state(struct entry_point_info *pnc_entry_point,
 	assert(pc);
 
 	/* Associate this context with the current cpu */
-	pnc_ctx->mpidr = read_mpidr();
+	pnc_ctx->mpidr = read_mpidr() | BL32_MAIN_CPU;
 
-	cm_set_context(&pnc_ctx->cpu_ctx, SECURE);
+	cm_set_context_by_index(BL32_MAIN_CPU, &pnc_ctx->cpu_ctx, SECURE);
 
 	/* initialise an entrypoint to set up the CPU context */
 	ep_attr = SECURE | EP_ST_ENABLE;
diff --git a/services/spd/pncd/pncd_main.c b/services/spd/pncd/pncd_main.c
index 99c4aa1b2..c66ce1cf2 100644
--- a/services/spd/pncd/pncd_main.c
+++ b/services/spd/pncd/pncd_main.c
@@ -44,7 +44,7 @@ static uint64_t ree_base_addr;
 static uint64_t ree_length;
 static uint64_t ree_tag;
 
-static bool pnc_initialized;
+static volatile bool pnc_initialized = false;
 
 static spinlock_t smc_handler_lock;
 
@@ -91,8 +91,14 @@ static uint64_t pncd_sel1_interrupt_handler(uint32_t id,
  ******************************************************************************/
 void *pncd_context_switch_to(unsigned long security_state)
 {
+#if !defined(BL32_MAIN_CPU) || BL32_MAIN_CPU == 0
 	unsigned long sec_state_from =
 	    security_state == SECURE ? NON_SECURE : SECURE;
+#else
+	/* PnC is running on secondary core, should not switch security state */
+	unsigned long sec_state_from =
+	    security_state;
+#endif
 
 	assert(sec_state_is_valid(security_state));
 
@@ -131,6 +137,7 @@ void *pncd_context_switch_to(unsigned long security_state)
 		 */
 		spin_unlock(&smc_handler_lock);
 
+#if !defined(BL32_MAIN_CPU) || BL32_MAIN_CPU == 0
 		/*
 		 * SP reports completion. The SPD must have initiated
 		 * the original request through a synchronous entry
@@ -142,6 +149,7 @@ void *pncd_context_switch_to(unsigned long security_state)
 		/* Unreachable */
 		ERROR("Returned from pncd_synchronous_sp_exit... Should not happen\n");
 		panic();
+#endif
 	}
 
 	/* Check that the world switch is allowed */
@@ -261,14 +269,30 @@ static int32_t pncd_init(void)
 	pnc_entry_point = bl31_plat_get_next_image_ep_info(SECURE);
 	assert(pnc_entry_point);
 
+#if !defined(BL32_MAIN_CPU) || BL32_MAIN_CPU == 0
+
 	cm_init_my_context(pnc_entry_point);
 
 	/*
 	 * Arrange for an entry into the test secure payload. It will be
 	 * returned via PNC_ENTRY_DONE case
 	 */
+
 	rc = pncd_synchronous_sp_entry(&pncd_sp_context);
 
+#else
+       assert(pnc_entry_point->pc);
+
+       /* Turn on secondary CPU. */
+       rc = psci_cpu_on_start(BL32_MAIN_CPU, pnc_entry_point);
+
+       /* Waiting for pnc on secondary CPU. */
+       while (!pnc_initialized){
+               ;
+       }
+#endif
+
+
 	/*
 	 * If everything went well at this point, the return value should be 0.
 	 */
@@ -413,7 +437,14 @@ static uintptr_t pncd_smc_handler_unsafe(uint32_t smc_fid,
 
 	case SMC_YIELD:
 		assert(handle == cm_get_context(ns != 0 ? NON_SECURE : SECURE));
-		handle = pncd_context_switch_to(ns != 0 ? SECURE : NON_SECURE);
+
+		#if !defined(BL32_MAIN_CPU) || BL32_MAIN_CPU == 0
+			handle = pncd_context_switch_to(ns !=0  ? SECURE : NON_SECURE);
+		#else
+			/* PnC is running on secondary core,
+			* security state should not be switched */
+			handle = pncd_context_switch_to(ns != 0 ? NON_SECURE : SECURE);
+		#endif
 
 		assert(handle != NULL);
 
-- 
2.34.1

